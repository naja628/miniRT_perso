#include "scr.h"
#include "camera.h"
#include "vec.h"
#include "shape.h"
#include "line.h"
#include "mlx.h" // ok because -I sources/mlx_linux should find it
#include "cleanup.h"

// This line bad because gets mlx from system instead of our repo
// # include <mlx.h>
// Are these really needed? 
// # include <sys/mman.h>
// # include <X11/Xlib.h>
// # include <X11/Xutil.h>
// # include <sys/ipc.h>
// # include <sys/shm.h>
// # include <X11/extensions/XShm.h>
// # include <X11/XKBlib.h>

// int	ft_dir_rgb(t_line *ray)
// {
// 	t_vec	dir = ray->dir;
// 	t_uchar r = 0xff * (1 + dir.x) / 2;
// 	t_uchar g = 0xff * (1 + dir.y) / 2;
// 	t_uchar b = 0xff * (1 + dir.z) / 2;
// 	int rgb = 0;
// 	t_sphere	test = {ft_vec(0, 3, 0), 1};
// 	t_shape		s = {SHP_SPHERE, &test};
// 	float	dummy;
// 
// 	rgb |= b;
// 	rgb |= g << 8;
// 	rgb |= r << 16;
// 	if (ft_intersect(&dummy, ray, &s))
// 		rgb = 0x0000ff; // sphere is blue
// 	return (rgb);
// }

// int test(t_line *ray)
// {
// 	t_vec	lightpos = ft_vec(0, 1.5, 1.5);
// 	t_sphere sp = {ft_vec(0, 3, 0), 1};
// 	t_shape	s = {SHP_SPHERE, &sp};
// 	float	param;
// 	int		color;
// 
// 	if (ft_intersect(&param, ray, &s))
// 	{
// 		t_vec p = ft_point_at_t(ray, param);
// 		color = ft_compute_color(
// 				lightpos,
// 				0xffff, // cyan
// 				p,
// 				ft_normal(p, &s));
// 		return (color);
// 	}
// 	else 
// 		return 0; // black
// }

#include "../../includes/render.h"
#include "../../includes/color.h"
#include <stddef.h>

// adjusts the characteristics of the scene so things look "as they should" 
// after gamma-2 correction
void	ft_gamma_scene(t_scene *scene)
{
	t_shape_list	*its;
	t_light_list	*itl;

	scene->ambient *= scene->ambient;
// 	scene->light.intensity *= scene->light.intensity;
	itl = scene->lights;
	while (itl)
	{
		itl->light.intensity *= itl->light.intensity;
		itl = itl->next;
	}
	its = scene->shapes;
	while (its)
	{
		its->shape.color.x *= its->shape.color.x;
		its->shape.color.y *= its->shape.color.y;
		its->shape.color.z *= its->shape.color.z;
		its = its->next;
	}
}

#include <stdio.h>

#define RAYS_PP 4
#define BOUNCES 15
// send 4 (RAYS_PP) rays per pixel and average them to antialias somewhat
// TODO maybe put cam into scene so only 4 args (norminette)
static int ft_pixel_color(int x, int y, int scr_w, t_scene *sce, t_camera *cam)
{
	t_vec vrgb;
	t_line ray;
	const int xs[RAYS_PP] = {0, 1, 0, 1};
	const int ys[RAYS_PP] = {0, 0, 1, 1};
	int i;
	
	// times 2 because sqrt(4) (4 is RAYS_PP)
	x *= 2;
	y *= 2;
	vrgb = ft_vec(0, 0, 0);
	i = 0;
	scr_w = scr_w * 2 - 1;
	while (i < RAYS_PP)
	{
		ft_ray(&ray, (float)(x + xs[i]) / scr_w, (float)(y + ys[i]) / scr_w, cam);
		ft_add_to(&vrgb, ft_ray_color(&ray, sce, BOUNCES, 50));
		++i;
	}
	ft_scale(1.0 / RAYS_PP, &vrgb);
	// comment out for no gamma correction
	ft_gamma_correct(&vrgb);
	return (ft_vrgb_to_int(vrgb));
}
#undef RAYS_PP
#undef BOUNCES

#include "../../includes/bump_mapping.h"
#include <math.h> // for pi

#define MATTE 0.75, 0.15, 0.05
#define	POLISH 0.5, 0.25, 0.25
#define	SHINY 0.2, 0.05, 0.75
#define MIRROR 0.05, 0.05, 0.9
#define WHITE {1, 1, 1}
// void	ft_render_scr(t_scr *scr, t_camera *cam, t_scene *scene)
// {
	// hardcode list with two sphere

	// scene 1 (planetes, maybe undo 'Xmas' lights)
// 	t_vec	lightpos = ft_vec(4, 1.8, 0);
// 	t_sphere sp = {ft_vec(0, 3, 0), 1};
// 	t_sphere sp2 = {ft_vec(-4.5, 3, 0), 3};
// 	t_sphere sp3 = {ft_vec(0, 4, 1.5), 0.8};
// 	struct s_shape_list one = {{SHP_SPHERE, ft_color_vec(0x80ff), SHINY, &sp}, NULL};
// 	struct s_shape_list two = {{SHP_SPHERE, ft_color_vec(0x8000ff), SHINY, &sp3}, &one};
// 	struct s_shape_list objs = {{SHP_SPHERE, ft_color_vec(0xff8000), SHINY, &sp2}, &two};
// 	t_light_list li1 = {{lightpos, 0.7, {1, 0.10, 0.10}}, NULL};
// 	t_light_list lights = {{ft_vec(3, 4.5, 4), 0.7, {0.10, 1, 0.10}}, &li1};
// 	t_scene scene = {0.07, &lights, &objs};
// 	t_scene scene = {0.03, {lightpos, 1}, &objs};

	// scene 2 (with plane and intersections)
// 	t_sphere sp = {ft_vec(0, 3, -2), 1.5};
// 	t_sphere sp2 = {ft_vec(2, 15, -2), 1.5};
// 	t_plane pl = {ft_vec(0, 0, -2), ft_vec(0, 0, 1)};
// // 	struct s_shape_list xxx = {{xxx, ft_color_vec(xxx), &xxx}, xxx};
// 	struct s_shape_list one = {{SHP_PLANE, ft_color_vec(0x8000ff), SHINY, &pl}, NULL};
// 	struct s_shape_list two = {{SHP_SPHERE, ft_color_vec(0xff), SHINY, &sp2}, &one};
// 	struct s_shape_list objs = {{SHP_SPHERE, ft_color_vec(0xff0000), SHINY, &sp}, &two};
// 	t_scene scene = {0.05, {ft_vec(1.5, 3, 2), 0.7, WHITE}, &objs};

	// scene 3 (mirrors)
// 	t_sphere sp = {ft_vec(0, 2, 1), 1};
// 	t_plane pl1 = {ft_vec(0, 4, 1), ft_vec(0, -1, 0)};
// 	t_plane pl2 = {ft_vec(-2, 2, 1), ft_vec(1, 0, 0)};
// 	struct s_shape_list one = {{SHP_SPHERE, ft_color_vec(0xff0080), SHINY, &sp}, NULL};
// 	struct s_shape_list two = {{SHP_PLANE, ft_color_vec(0x404080), SHINY, &pl1}, &one};
// 	struct s_shape_list objs = {{SHP_PLANE, ft_color_vec(0x505050), SHINY, &pl2}, &two};
// 	t_light_list light = {{ft_vec(1, 1, 3), 0.7, WHITE}, NULL};
// 	t_scene scene = {0.10, &light, &objs};

	// scene 4 (bi-color)
// 	t_sphere sp1 = {ft_vec(-1.5, 1, -1), 1};
// 	t_sphere sp2 = {ft_vec(1.5, 1, -1), 1};
// 	t_plane wall = {ft_vec(0, 4, 0), ft_vec(0, 1, 0)};
// // 	t_plane floor = {ft_vec(0, -2, 0), ft_vec(0, 0, 1)};
// 	t_plane floor = {ft_vec(0, 0, -2), ft_vec(0, 0, 1)};
// 	t_shape_list one = {{SHP_SPHERE, ft_color_vec(0x808080), 0, SHINY, &sp1}, NULL};
// 	t_shape_list two = {{SHP_SPHERE, ft_color_vec(0x0050ff), 1, MATTE, &sp2}, &one};
// 	t_shape_list three = {{SHP_PLANE, ft_color_vec(0xa0a0a0), 1, MATTE, &wall}, &two};
// 	t_shape_list objs = {{SHP_PLANE, ft_color_vec(0xa0a0a0), 0, SHINY, &floor}, &three};
// 	//
// 	t_light_list li1 = {{ft_vec(-3.5, -1, 0), 0.7, {1, 0.5, 0}}, NULL};
// 	t_light_list lights = {{ft_vec(3.5, -1, 0), 0.7, {0, 0.5, 1}}, &li1};
// 	t_scene scene = {0.15, &lights, &objs};

	// scene 5 (insde sphere)
// 	t_sphere outer = {ft_vec(0, 0, 0), 6};
// 	t_plane floor = {ft_vec(0, 0, -1), ft_vec(0, 0, 1)};
// 	t_sphere sp1 = {ft_vec(-0.5, 2, 0), 1};
// 	t_shape_list one = {{SHP_SPHERE, ft_color_vec(0x808080), MIRROR, &outer}, NULL};
// 	t_shape_list two = {{SHP_SPHERE, ft_color_vec(0x8000ff), POLISH, &sp1}, &one};
// // 	t_shape_list objs = {{SHP_PLANE, ft_color_vec(0xff8000), MATTE, &floor}, &two};
// 	t_light_list li1 = {{ft_vec(0, 0, 5), 0.7, {1, 1, 1}}, NULL};
// 	t_scene scene = {0.15, &li1, &two};

	// scene 6 (test checkering)
// 	t_plane pl = {ft_vec(0, 0, -1), ft_vec(0.8, -0.6, 0)};
// 	t_shape_list obj = {{SHP_PLANE, ft_color_vec(0xffffff), 1, MATTE, &pl}, NULL};
// 	t_light_list light = {{ft_vec(4, 0, 3), 0.7, {1, 1, 0.5}}, NULL};
// 	t_scene scene = {0.15, &light, &obj};

	// scene 7 (bronze earth)
// 	t_plane floor = {ft_vec(0, 0, -1), ft_vec(0, 0, 1)};
// 	t_sphere earth = {ft_vec(0, 0, 0), 1};
// 
// 	t_imdata tmp;
// 	ft_xpm_to_imdata(scr->mlx, "test.xpm", &tmp);
// 	t_normals topo;	
// 	ft_mk_normal_map(&topo, &tmp, 1.0 / 40);
// 	printf("topo->data at %p\n", topo.data);
// // 	t_shape_list one = {{SHP_SPHERE, ft_color_vec(0xcd7f32), 0, POLISH, &earth, &topo, M_PI}, NULL};
// 	t_shape_list one = {{SHP_SPHERE, ft_color_vec(0xff0040), 0, POLISH, &earth, &topo, M_PI}, NULL};
// 	t_shape_list objs = {{SHP_PLANE, ft_color_vec(0xffffff), 1, MATTE, &floor, NULL}, &one};
// 	t_light_list light = {{ft_vec(0, -1, 5), 0.7, {1, 1, 0.5}}, NULL};
// 	t_scene scene = {0.15, &light, &objs};

// 	// scene 8 a cylinder
// 	t_plane floor = {ft_vec(0, 0, -1), ft_vec(0, 0, 1)};
// 	t_cone cn = {ft_vec(0, 0, 0), ft_vec(0, 0, 1), 0.25, M_PI};
// 	t_shape_list one = {{SHP_PLANE, &floor, ft_color_vec(0x80ff), 0, POLISH}, NULL};
// 	t_shape_list objs = {{SHP_CONE, &cn, ft_color_vec(0x8000ff), 1, SHINY}, &one};
// 	t_light_list light = {{ft_vec(0, -3, 5), 0.7, {1, 1, 0.5}}, NULL};
// // 	t_vec middle = ft_vec_add(cy.p, ft_scaled(M_PI / 2, cy.dir));
// // 	t_light_list light = {{middle, 0.7, {1, 1, 0.5}}, NULL};
// 	t_scene scene = {0.40, ft_vec(1, 0, .25), &light, &objs};

#include <stdio.h>
void	ft_render_scr(t_scr *scr, t_camera *cam, t_scene *scene)
{
	// comment out for no gamma correction
	ft_gamma_scene(scene);

	int color;
	for (int x = 0; x < scr->w; ++x)
	{
		for (int y = 0; y < scr->h; ++y)
		{
			color = ft_pixel_color(x, y, scr->w, scene, cam);
			ft_pixel_to_scr(scr, x, y, mlx_get_color_value(scr->mlx, color));
		}
	}
}

// int	main()
// {
// 	t_scr	scr;
// 	t_camera cam;
// 	t_vec	dir;

// 	ft_init_scr(&scr, 1000, 700, "no gamma");
// // 	dir = ft_vec(-1, 0, 0);
// 	dir = ft_vec(0, 1, 0);
// // 	dir = ft_vec(0, 0.707, -0.707);
// // 	dir = ft_vec(-1, 1, 0);
// 	ft_make_unit(&dir);
// 	ft_init_camera(
// 			&cam, 
// // 			ft_vec(5, 0, 0),
// 			ft_vec(0, -8, 0), 
// // 			ft_vec(0, -5, 5), 
// // 			ft_vec(5, -3, 0),
// 			dir,
// 			70);
// 	ft_mk_camscreen(&cam, (float) 700 / 1000);
// 	ft_render_scr(&scr, &cam);
// 	mlx_put_image_to_window(scr.mlx, scr.win, scr.imptr, 0, 0);
// 	t_mem mem = { NULL, &scr};
// 	mlx_key_hook(scr.win, ft_esc_exit_hook, &mem);
// 	mlx_hook(scr.win, 17, 0, ft_quit, &mem);
// 	mlx_loop(scr.mlx);
// }
